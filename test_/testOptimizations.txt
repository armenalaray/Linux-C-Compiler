sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)
8
['/home/alejandro/CComp/code/cd.py', '-lmath.h', '--fold-constants', '--propagate-copies', '--eliminate-unreachable-code', '--eliminate-dead-stores', '--optimize', '/home/alejandro/CComp/test_/test.c']
File: /home/alejandro/CComp/test_/test.c
Last Stage: codeEmission
NoLink: False
NotAssembly: False
--fold-constants True
--propagate-copies True
--eliminate-unreachable-code True
--eliminate-dead-stores True
--optimize True
Libary: math.h
[('int', <TokenType.INT_KW: 4>, 1), ('b', <TokenType.IDENTIFIER: 2>, 1), ('=', <TokenType.EQUAL: 28>, 1), ('0', <TokenType.INT_CONSTANT: 3>, 1), (';', <TokenType.SEMICOLON: 11>, 1), ('void', <TokenType.VOID_KW: 5>, 2), ('callee', <TokenType.IDENTIFIER: 2>, 2), ('(', <TokenType.OPEN_PAREN: 7>, 2), ('int', <TokenType.INT_KW: 4>, 2), ('*', <TokenType.ASTERISK: 17>, 2), ('ptr', <TokenType.IDENTIFIER: 2>, 2), (')', <TokenType.CLOSE_PAREN: 8>, 2), ('{', <TokenType.OPEN_BRACE: 9>, 2), ('b', <TokenType.IDENTIFIER: 2>, 3), ('=', <TokenType.EQUAL: 28>, 3), ('*', <TokenType.ASTERISK: 17>, 3), ('ptr', <TokenType.IDENTIFIER: 2>, 3), (';', <TokenType.SEMICOLON: 11>, 3), ('*', <TokenType.ASTERISK: 17>, 4), ('ptr', <TokenType.IDENTIFIER: 2>, 4), ('=', <TokenType.EQUAL: 28>, 4), ('100', <TokenType.INT_CONSTANT: 3>, 4), (';', <TokenType.SEMICOLON: 11>, 4), ('}', <TokenType.CLOSE_BRACE: 10>, 5), ('int', <TokenType.INT_KW: 4>, 6), ('target', <TokenType.IDENTIFIER: 2>, 6), ('(', <TokenType.OPEN_PAREN: 7>, 6), ('void', <TokenType.VOID_KW: 5>, 6), (')', <TokenType.CLOSE_PAREN: 8>, 6), ('{', <TokenType.OPEN_BRACE: 9>, 6), ('int', <TokenType.INT_KW: 4>, 7), ('x', <TokenType.IDENTIFIER: 2>, 7), ('=', <TokenType.EQUAL: 28>, 7), ('10', <TokenType.INT_CONSTANT: 3>, 7), (';', <TokenType.SEMICOLON: 11>, 7), ('callee', <TokenType.IDENTIFIER: 2>, 8), ('(', <TokenType.OPEN_PAREN: 7>, 8), ('&', <TokenType.AMPERSAND: 49>, 8), ('x', <TokenType.IDENTIFIER: 2>, 8), (')', <TokenType.CLOSE_PAREN: 8>, 8), (';', <TokenType.SEMICOLON: 11>, 8), ('int', <TokenType.INT_KW: 4>, 9), ('y', <TokenType.IDENTIFIER: 2>, 9), ('=', <TokenType.EQUAL: 28>, 9), ('x', <TokenType.IDENTIFIER: 2>, 9), (';', <TokenType.SEMICOLON: 11>, 9), ('x', <TokenType.IDENTIFIER: 2>, 10), ('=', <TokenType.EQUAL: 28>, 10), ('50', <TokenType.INT_CONSTANT: 3>, 10), (';', <TokenType.SEMICOLON: 11>, 10), ('return', <TokenType.RETURN_KW: 6>, 11), ('y', <TokenType.IDENTIFIER: 2>, 11), (';', <TokenType.SEMICOLON: 11>, 11), ('}', <TokenType.CLOSE_BRACE: 10>, 12), ('int', <TokenType.INT_KW: 4>, 13), ('main', <TokenType.IDENTIFIER: 2>, 13), ('(', <TokenType.OPEN_PAREN: 7>, 13), ('void', <TokenType.VOID_KW: 5>, 13), (')', <TokenType.CLOSE_PAREN: 8>, 13), ('{', <TokenType.OPEN_BRACE: 9>, 13), ('int', <TokenType.INT_KW: 4>, 14), ('a', <TokenType.IDENTIFIER: 2>, 14), ('=', <TokenType.EQUAL: 28>, 14), ('target', <TokenType.IDENTIFIER: 2>, 14), ('(', <TokenType.OPEN_PAREN: 7>, 14), (')', <TokenType.CLOSE_PAREN: 8>, 14), (';', <TokenType.SEMICOLON: 11>, 14), ('if', <TokenType.IF_KW: 31>, 15), ('(', <TokenType.OPEN_PAREN: 7>, 15), ('a', <TokenType.IDENTIFIER: 2>, 15), ('!=', <TokenType.EXCLAMATIONEQUAL: 25>, 15), ('100', <TokenType.INT_CONSTANT: 3>, 15), (')', <TokenType.CLOSE_PAREN: 8>, 15), ('{', <TokenType.OPEN_BRACE: 9>, 15), ('return', <TokenType.RETURN_KW: 6>, 16), ('1', <TokenType.INT_CONSTANT: 3>, 16), (';', <TokenType.SEMICOLON: 11>, 16), ('}', <TokenType.CLOSE_BRACE: 10>, 17), ('if', <TokenType.IF_KW: 31>, 18), ('(', <TokenType.OPEN_PAREN: 7>, 18), ('b', <TokenType.IDENTIFIER: 2>, 18), ('!=', <TokenType.EXCLAMATIONEQUAL: 25>, 18), ('10', <TokenType.INT_CONSTANT: 3>, 18), (')', <TokenType.CLOSE_PAREN: 8>, 18), ('{', <TokenType.OPEN_BRACE: 9>, 18), ('return', <TokenType.RETURN_KW: 6>, 19), ('2', <TokenType.INT_CONSTANT: 3>, 19), (';', <TokenType.SEMICOLON: 11>, 19), ('}', <TokenType.CLOSE_BRACE: 10>, 20), ('return', <TokenType.RETURN_KW: 6>, 21), ('0', <TokenType.INT_CONSTANT: 3>, 21), (';', <TokenType.SEMICOLON: 11>, 21), ('}', <TokenType.CLOSE_BRACE: 10>, 22)]
<parser.Int object at 0x7ff4f640b1d0>
[<parser.TypeS object at 0x7ff4f642b440>]
[<class 'parser.Int'>]
int
int (IdenDeclarator: b)
int
<parser.Void object at 0x7ff4f640b1d0>
[<parser.TypeS object at 0x7ff4f642b470>]
[<class 'parser.Void'>]
void
[<class 'parser.Int'>]
void (FunDeclarator: (IdenDeclarator: callee) [int (PointerDeclarator: (IdenDeclarator: ptr))])
FunType: ParamTypes: [Pint] Return Type: void
<parser.Int object at 0x7ff4f640b1d0>
[<parser.TypeS object at 0x7ff4f642b650>]
[<class 'parser.Int'>]
int
int (FunDeclarator: (IdenDeclarator: target) [])
FunType: ParamTypes: [] Return Type: int
<parser.Int object at 0x7ff4f642bbc0>
[<parser.TypeS object at 0x7ff4f642bbf0>]
[<class 'parser.Int'>]
int
int (IdenDeclarator: x)
int
<parser.Int object at 0x7ff4f642be00>
[<parser.TypeS object at 0x7ff4f642be30>]
[<class 'parser.Int'>]
int
int (IdenDeclarator: y)
int
<parser.Int object at 0x7ff4f642b770>
[<parser.TypeS object at 0x7ff4f642b800>]
[<class 'parser.Int'>]
int
int (FunDeclarator: (IdenDeclarator: main) [])
FunType: ParamTypes: [] Return Type: int
<parser.Int object at 0x7ff4f6460230>
[<parser.TypeS object at 0x7ff4f6460260>]
[<class 'parser.Int'>]
int
int (IdenDeclarator: a)
int
0
0
0
1
1
AST Program:
VarDecl: NULL int b = SI: (0)
FunDecl: NULL callee (ptr, ) ParamTypes: (Pint, ) ReturnType: void
Statement: Expression: ((b) = (*(ptr)))
Statement: Expression: ((*(ptr)) = (100))
FunDecl: NULL target () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int x = SI: (10)
Statement: Expression: (callee((&(x)), ))
Declaration:
VarDecl: NULL int y = SI: (x)
Statement: Expression: ((x) = (50))
Statement: return (y)
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int a = SI: (target())
Statement: if (((a) NOTEQUAL (100)))
	Statement: return (1)
Statement: if (((b) NOTEQUAL (10)))
	Statement: return (2)
Statement: return (0)

OLD {}
NEW {}
OLD {}
NEW {}
OLD {}
NEW {}
OLD {}
NEW {}
OLD {}
NEW {}
0
0
0
1
1
AST Program:
VarDecl: NULL int b = SI: (0)
FunDecl: NULL callee (ptr.0, ) ParamTypes: (Pint, ) ReturnType: void
Statement: Expression: ((b) = (*(ptr.0)))
Statement: Expression: ((*(ptr.0)) = (100))
FunDecl: NULL target () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int x.1 = SI: (10)
Statement: Expression: (callee((&(x.1)), ))
Declaration:
VarDecl: NULL int y.2 = SI: (x.1)
Statement: Expression: ((x.1) = (50))
Statement: return (y.2)
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int a.3 = SI: (target())
Statement: if (((a.3) NOTEQUAL (100)))
	Statement: return (1)
Statement: if (((b) NOTEQUAL (10)))
	Statement: return (2)
Statement: return (0)

[&(x.1 RetType: int) RetType: Pint]
0
0
0
1
1
AST Program:
VarDecl: NULL int b = SI: (0 : int) : int
FunDecl: NULL callee (ptr.0, ) ParamTypes: (Pint, ) ReturnType: void
Statement: Expression: ((b : int) = (*(ptr.0 : Pint) : int) : int)
Statement: Expression: ((*(ptr.0 : Pint) : int) = (100 : int) : int)
FunDecl: NULL target () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int x.1 = SI: (10 : int) : int
Statement: Expression: (callee((&(x.1 : int) : Pint), ) : void)
Declaration:
VarDecl: NULL int y.2 = SI: (x.1 : int) : int
Statement: Expression: ((x.1 : int) = (50 : int) : int)
Statement: return (y.2 : int)
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int a.3 = SI: (target() : int) : int
Statement: if (((a.3 : int) NOTEQUAL (100 : int) : int))
	Statement: return (1 : int)
Statement: if (((b : int) NOTEQUAL (10 : int) : int))
	Statement: return (2 : int)
Statement: return (0 : int)

Type Table:
 {}
Symbol Table:
 {'b': b int InitialVal: InitialList: [c_int(0)] Global: True, 'callee': callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True, 'ptr.0': ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>, 'target': target FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'x.1': x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>, 'y.2': y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>, 'main': main FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'a.3': a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>}
0
0
0
1
1
AST Program:
VarDecl: NULL int b = SI: (0 : int) : int
FunDecl: NULL callee (ptr.0, ) ParamTypes: (Pint, ) ReturnType: void
Statement: Expression: ((b : int) = (*(ptr.0 : Pint) : int) : int)
Statement: Expression: ((*(ptr.0 : Pint) : int) = (100 : int) : int)
FunDecl: NULL target () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int x.1 = SI: (10 : int) : int
Statement: Expression: (callee((&(x.1 : int) : Pint), ) : void)
Declaration:
VarDecl: NULL int y.2 = SI: (x.1 : int) : int
Statement: Expression: ((x.1 : int) = (50 : int) : int)
Statement: return (y.2 : int)
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int a.3 = SI: (target() : int) : int
Statement: if (((a.3 : int) NOTEQUAL (100 : int) : int))
	Statement: return (1 : int)
Statement: if (((b : int) NOTEQUAL (10 : int) : int))
	Statement: return (2 : int)
Statement: return (0 : int)

b int InitialVal: InitialList: [c_int(0)] Global: True
callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True
ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>
target FunType: ParamTypes: [] Return Type: int Defined: True Global: True
x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>
y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>
main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>
tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>
tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>
tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>
tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>
tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>
tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>
tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>
tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>
TAC Program:[Function: callee (['ptr.0']) instructions:[tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0], Function: target ([]) instructions:[CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2, Return 0], Function: main ([]) instructions:[tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13), Return 2, Label(tmp.13), Return 0, Return 0], Global: True b = [c_int(0)]]
Type Table:
 {}
Symbol Table:
 {'b': b int InitialVal: InitialList: [c_int(0)] Global: True, 'callee': callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True, 'ptr.0': ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>, 'target': target FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'x.1': x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>, 'y.2': y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>, 'main': main FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'a.3': a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>, 'tmp.4': tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>, 'tmp.5': tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>, 'tmp.6': tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>, 'tmp.7': tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>, 'tmp.8': tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>, 'tmp.9': tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>, 'tmp.11': tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>, 'tmp.12': tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>}
OPTIMIZING FUNCTION Function: callee (['ptr.0']) instructions:[tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0]
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0]
NEW LIST [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0]
<class 'tacGenerator.TAC_Load'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_Store'>
<class 'tacGenerator.TAC_returnInstruction'>
tmp.4 = Load ptr.0 


ENTRY Entry: ENTRY {0}
0 0: [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {tmp.4 = Load ptr.0 : set(), Copy b = tmp.4: set(), ptr.0 = Store 100 : set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {tmp.4 = Load ptr.0 : set(), Copy b = tmp.4: set(), ptr.0 = Store 100 : set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {tmp.4 = Load ptr.0 : set(), Copy b = tmp.4: set(), ptr.0 = Store 100 : set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {tmp.4 = Load ptr.0 : set(), Copy b = tmp.4: set(), ptr.0 = Store 100 : set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
tmp.4 = Load ptr.0  set()
Copy b = tmp.4 set()
ptr.0 = Store 100  {Copy b = tmp.4}
Return 0 {Copy b = tmp.4}
OLD ANNOT: {Copy b = tmp.4}
NEW ANNOT: {Copy b = tmp.4}
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {tmp.4 = Load ptr.0 : set(), Copy b = tmp.4: set(), ptr.0 = Store 100 : {Copy b = tmp.4}, Return 0: {Copy b = tmp.4}} ReachingCopies: {Copy b = tmp.4}
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
b b int InitialVal: InitialList: [c_int(0)] Global: True
callee callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True
ptr.0 ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>
target target FunType: ParamTypes: [] Return Type: int Defined: True Global: True
x.1 x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>
y.2 y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
a.3 a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>
tmp.5 tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>
tmp.6 tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>
tmp.7 tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>
tmp.8 tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>
tmp.9 tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>
tmp.11 tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>
tmp.12 tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>
--------------LIVE for block 0-------------------
Return 0 {b}
ptr.0 = Store 100  {b}
Copy b = tmp.4 {ptr.0, b}
tmp.4 = Load ptr.0  {ptr.0, tmp.4}
OLD ANNOT: set()
NEW ANNOT: {ptr.0}
------------REMOVE DEAD STORE INSTRUCTIONS.-------------
------------AFTER DEAD STORE REMOVAL.-------------
ENTRY Entry: ENTRY {0}
0 0: [tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {tmp.4 = Load ptr.0 : {ptr.0, tmp.4}, Copy b = tmp.4: {ptr.0, b}, ptr.0 = Store 100 : {b}, Return 0: {b}} ReachingCopies: {ptr.0}
EXIT Exit: EXIT {0}
OPTIMIZING FUNCTION Function: target ([]) instructions:[CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2, Return 0]
--------------ADDRESS TAKEN ANALYSIS.------------------
{x.1}
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2, Return 0]
NEW LIST [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2, Return 0]
<class 'tacGenerator.TAC_copyToOffset'>
<class 'tacGenerator.TAC_GetAddress'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_FunCallInstruction'>
<class 'tacGenerator.TAC_copyToOffset'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
CopyToOffset(x.1 + 0) = 10 
Return 0



ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), Copy tmp.6 = tmp.5: set(), None = callee([tmp.6]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Copy x.1 = 50: set(), Return y.2: set()} ReachingCopies: set()
1 1: [Return 0] Pred: set() Suc: {EXIT} iMap: {Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0, 1}
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), Copy tmp.6 = tmp.5: set(), None = callee([tmp.6]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Copy x.1 = 50: set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), Copy tmp.6 = tmp.5: set(), None = callee([tmp.6]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Copy x.1 = 50: set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.6]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), Copy tmp.6 = tmp.5: set(), None = callee([tmp.6]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Copy x.1 = 50: set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
CopyToOffset(x.1 + 0) = 10  set()
tmp.5 = Get Address x.1  set()
Copy tmp.6 = tmp.5 set()
None = callee([tmp.6]) {Copy tmp.6 = tmp.5}
CopyToOffset(y.2 + 0) = x.1  {Copy tmp.6 = tmp.5}
Copy x.1 = 50 {Copy tmp.6 = tmp.5}
<class 'parser.ConstInt'>
Return y.2 {Copy tmp.6 = tmp.5, Copy x.1 = 50}
OLD ANNOT: {Copy tmp.6 = tmp.5, Copy x.1 = 50}
NEW ANNOT: {Copy tmp.6 = tmp.5, Copy x.1 = 50}
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , Copy tmp.6 = tmp.5, None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Copy x.1 = 50, Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), Copy tmp.6 = tmp.5: set(), None = callee([tmp.6]): {Copy tmp.6 = tmp.5}, CopyToOffset(y.2 + 0) = x.1 : {Copy tmp.6 = tmp.5}, Copy x.1 = 50: {Copy tmp.6 = tmp.5}, Return y.2: {Copy tmp.6 = tmp.5, Copy x.1 = 50}} ReachingCopies: {Copy tmp.6 = tmp.5, Copy x.1 = 50}
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
b b int InitialVal: InitialList: [c_int(0)] Global: True
callee callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True
ptr.0 ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>
target target FunType: ParamTypes: [] Return Type: int Defined: True Global: True
x.1 x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>
y.2 y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
a.3 a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>
tmp.5 tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>
tmp.6 tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>
tmp.7 tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>
tmp.8 tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>
tmp.9 tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>
tmp.11 tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>
tmp.12 tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>
--------------LIVE for block 0-------------------
Return y.2 {b}
Copy x.1 = 50 {b, y.2}
CopyToOffset(y.2 + 0) = x.1  {b, y.2}
None = callee([tmp.5]) {b, x.1, y.2}
<class 'tacGenerator.TAC_VariableValue'>
Copy tmp.6 = tmp.5 {tmp.5, b, x.1, y.2}
tmp.5 = Get Address x.1  {tmp.5, b, x.1, y.2}
CopyToOffset(x.1 + 0) = 10  {b, x.1, y.2}
OLD ANNOT: set()
NEW ANNOT: {b, x.1, y.2}
------------REMOVE DEAD STORE INSTRUCTIONS.-------------
Copy tmp.6 = tmp.5 {tmp.5, b, x.1, y.2} for node 0
Copy x.1 = 50 {b, y.2} for node 0
------------AFTER DEAD STORE REMOVAL.-------------
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : {b, x.1, y.2}, tmp.5 = Get Address x.1 : {tmp.5, b, x.1, y.2}, Copy tmp.6 = tmp.5: {tmp.5, b, x.1, y.2}, None = callee([tmp.5]): {b, x.1, y.2}, CopyToOffset(y.2 + 0) = x.1 : {b, y.2}, Copy x.1 = 50: {b, y.2}, Return y.2: {b}} ReachingCopies: {b, x.1, y.2}
EXIT Exit: EXIT {0}
--------------ADDRESS TAKEN ANALYSIS.------------------
{x.1}
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2]
NEW LIST [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2]
<class 'tacGenerator.TAC_copyToOffset'>
<class 'tacGenerator.TAC_GetAddress'>
<class 'tacGenerator.TAC_FunCallInstruction'>
<class 'tacGenerator.TAC_copyToOffset'>
<class 'tacGenerator.TAC_returnInstruction'>
CopyToOffset(x.1 + 0) = 10 


ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), None = callee([tmp.5]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), None = callee([tmp.5]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), None = callee([tmp.5]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), None = callee([tmp.5]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
CopyToOffset(x.1 + 0) = 10  set()
tmp.5 = Get Address x.1  set()
None = callee([tmp.5]) set()
CopyToOffset(y.2 + 0) = x.1  set()
Return y.2 set()
OLD ANNOT: set()
NEW ANNOT: set()
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : set(), tmp.5 = Get Address x.1 : set(), None = callee([tmp.5]): set(), CopyToOffset(y.2 + 0) = x.1 : set(), Return y.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
b b int InitialVal: InitialList: [c_int(0)] Global: True
callee callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True
ptr.0 ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>
target target FunType: ParamTypes: [] Return Type: int Defined: True Global: True
x.1 x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>
y.2 y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
a.3 a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>
tmp.5 tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>
tmp.6 tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>
tmp.7 tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>
tmp.8 tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>
tmp.9 tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>
tmp.11 tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>
tmp.12 tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>
--------------LIVE for block 0-------------------
Return y.2 {b}
CopyToOffset(y.2 + 0) = x.1  {b, y.2}
None = callee([tmp.5]) {b, x.1, y.2}
<class 'tacGenerator.TAC_VariableValue'>
tmp.5 = Get Address x.1  {tmp.5, b, x.1, y.2}
CopyToOffset(x.1 + 0) = 10  {b, x.1, y.2}
OLD ANNOT: set()
NEW ANNOT: {b, x.1, y.2}
------------REMOVE DEAD STORE INSTRUCTIONS.-------------
------------AFTER DEAD STORE REMOVAL.-------------
ENTRY Entry: ENTRY {0}
0 0: [CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2] Pred: {ENTRY} Suc: {EXIT} iMap: {CopyToOffset(x.1 + 0) = 10 : {b, x.1, y.2}, tmp.5 = Get Address x.1 : {tmp.5, b, x.1, y.2}, None = callee([tmp.5]): {b, x.1, y.2}, CopyToOffset(y.2 + 0) = x.1 : {b, y.2}, Return y.2: {b}} ReachingCopies: {b, x.1, y.2}
EXIT Exit: EXIT {0}
OPTIMIZING FUNCTION Function: main ([]) instructions:[tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13), Return 2, Label(tmp.13), Return 0, Return 0]
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13), Return 2, Label(tmp.13), Return 0, Return 0]
NEW LIST [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13), Return 2, Label(tmp.13), Return 0, Return 0]
<class 'tacGenerator.TAC_FunCallInstruction'>
<class 'tacGenerator.TAC_copyToOffset'>
<class 'tacGenerator.TAC_BinaryInstruction'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_JumpIfZeroInst'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_LabelInst'>
<class 'tacGenerator.TAC_BinaryInstruction'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_JumpIfZeroInst'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_LabelInst'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
tmp.7 = target([])
Return 1
Label(tmp.10)
Return 2
Label(tmp.13)
Return 0









ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), Copy tmp.9 = tmp.8: set(), JumpIfZero(tmp.9, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), Copy tmp.12 = tmp.11: set(), JumpIfZero(tmp.12, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
5 5: [Return 0] Pred: set() Suc: {EXIT} iMap: {Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4, 5}
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), Copy tmp.9 = tmp.8: set(), JumpIfZero(tmp.9, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), Copy tmp.12 = tmp.11: set(), JumpIfZero(tmp.12, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), Copy tmp.9 = tmp.8: set(), JumpIfZero(tmp.9, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), Copy tmp.12 = tmp.11: set(), JumpIfZero(tmp.12, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.9, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), Copy tmp.9 = tmp.8: set(), JumpIfZero(tmp.9, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.12, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), Copy tmp.12 = tmp.11: set(), JumpIfZero(tmp.12, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
--------------IMAP for block 0-------------------
tmp.7 = target([]) set()
CopyToOffset(a.3 + 0) = tmp.7  set()
tmp.8 = a.3 != 100 set()
Copy tmp.9 = tmp.8 set()
JumpIfZero(tmp.9, tmp.10) {Copy tmp.9 = tmp.8}
OLD ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
NEW ANNOT: {Copy tmp.9 = tmp.8}
ADD SUCCESSORS.
--------------IMAP for block 1-------------------
Return 1 {Copy tmp.9 = tmp.8}
OLD ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
NEW ANNOT: {Copy tmp.9 = tmp.8}
ADD SUCCESSORS.
--------------IMAP for block 2-------------------
Label(tmp.10) {Copy tmp.9 = tmp.8}
tmp.11 = b != 10 {Copy tmp.9 = tmp.8}
Copy tmp.12 = tmp.11 {Copy tmp.9 = tmp.8}
JumpIfZero(tmp.12, tmp.13) {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
OLD ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
NEW ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
--------------IMAP for block 3-------------------
Return 2 {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
OLD ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
NEW ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
--------------IMAP for block 4-------------------
Label(tmp.13) {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
Return 0 {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
OLD ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
NEW ANNOT: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, Copy tmp.9 = tmp.8, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), Copy tmp.9 = tmp.8: set(), JumpIfZero(tmp.9, tmp.10): {Copy tmp.9 = tmp.8}} ReachingCopies: {Copy tmp.9 = tmp.8}
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: {Copy tmp.9 = tmp.8}} ReachingCopies: {Copy tmp.9 = tmp.8}
2 2: [Label(tmp.10), tmp.11 = b != 10, Copy tmp.12 = tmp.11, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): {Copy tmp.9 = tmp.8}, tmp.11 = b != 10: {Copy tmp.9 = tmp.8}, Copy tmp.12 = tmp.11: {Copy tmp.9 = tmp.8}, JumpIfZero(tmp.12, tmp.13): {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}} ReachingCopies: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}} ReachingCopies: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}, Return 0: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}} ReachingCopies: {Copy tmp.12 = tmp.11, Copy tmp.9 = tmp.8}
EXIT Exit: EXIT {1, 3, 4}
--------------ADDING ALL STATIC VARIABLES.------------------
b b int InitialVal: InitialList: [c_int(0)] Global: True
callee callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True
ptr.0 ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>
target target FunType: ParamTypes: [] Return Type: int Defined: True Global: True
x.1 x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>
y.2 y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
a.3 a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>
tmp.5 tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>
tmp.6 tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>
tmp.7 tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>
tmp.8 tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>
tmp.9 tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>
tmp.11 tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>
tmp.12 tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>
--------------LIVE for block 4-------------------
Return 0 {b}
Label(tmp.13) {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 3-------------------
Return 2 {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 2-------------------
JumpIfZero(tmp.11, tmp.13) {b}
Copy tmp.12 = tmp.11 {tmp.11, b}
tmp.11 = b != 10 {tmp.11, b}
Label(tmp.10) {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 1-------------------
Return 1 {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 0-------------------
JumpIfZero(tmp.8, tmp.10) {b}
Copy tmp.9 = tmp.8 {b, tmp.8}
tmp.8 = a.3 != 100 {b, tmp.8}
CopyToOffset(a.3 + 0) = tmp.7  {a.3, b}
tmp.7 = target([]) {a.3, b, tmp.7}
OLD ANNOT: set()
NEW ANNOT: {a.3, b}
------------REMOVE DEAD STORE INSTRUCTIONS.-------------
Copy tmp.9 = tmp.8 {b, tmp.8} for node 0
Copy tmp.12 = tmp.11 {tmp.11, b} for node 2
------------AFTER DEAD STORE REMOVAL.-------------
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): {a.3, b, tmp.7}, CopyToOffset(a.3 + 0) = tmp.7 : {a.3, b}, tmp.8 = a.3 != 100: {b, tmp.8}, Copy tmp.9 = tmp.8: {b, tmp.8}, JumpIfZero(tmp.8, tmp.10): {b}} ReachingCopies: {a.3, b}
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: {b}} ReachingCopies: {b}
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): {b}, tmp.11 = b != 10: {tmp.11, b}, Copy tmp.12 = tmp.11: {tmp.11, b}, JumpIfZero(tmp.11, tmp.13): {b}} ReachingCopies: {b}
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: {b}} ReachingCopies: {b}
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): {b}, Return 0: {b}} ReachingCopies: {b}
EXIT Exit: EXIT {1, 3, 4}
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13), Return 2, Label(tmp.13), Return 0]
NEW LIST [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13), Return 2, Label(tmp.13), Return 0]
<class 'tacGenerator.TAC_FunCallInstruction'>
<class 'tacGenerator.TAC_copyToOffset'>
<class 'tacGenerator.TAC_BinaryInstruction'>
<class 'tacGenerator.TAC_JumpIfZeroInst'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_LabelInst'>
<class 'tacGenerator.TAC_BinaryInstruction'>
<class 'tacGenerator.TAC_JumpIfZeroInst'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_LabelInst'>
<class 'tacGenerator.TAC_returnInstruction'>
tmp.7 = target([])
Return 1
Label(tmp.10)
Return 2
Label(tmp.13)








ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), JumpIfZero(tmp.8, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), JumpIfZero(tmp.11, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), JumpIfZero(tmp.8, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), JumpIfZero(tmp.11, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), JumpIfZero(tmp.8, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), JumpIfZero(tmp.11, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), JumpIfZero(tmp.8, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), JumpIfZero(tmp.11, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
--------------IMAP for block 0-------------------
tmp.7 = target([]) set()
CopyToOffset(a.3 + 0) = tmp.7  set()
tmp.8 = a.3 != 100 set()
JumpIfZero(tmp.8, tmp.10) set()
OLD ANNOT: set()
NEW ANNOT: set()
--------------IMAP for block 1-------------------
Return 1 set()
OLD ANNOT: set()
NEW ANNOT: set()
--------------IMAP for block 2-------------------
Label(tmp.10) set()
tmp.11 = b != 10 set()
JumpIfZero(tmp.11, tmp.13) set()
OLD ANNOT: set()
NEW ANNOT: set()
--------------IMAP for block 3-------------------
Return 2 set()
OLD ANNOT: set()
NEW ANNOT: set()
--------------IMAP for block 4-------------------
Label(tmp.13) set()
Return 0 set()
OLD ANNOT: set()
NEW ANNOT: set()
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): set(), CopyToOffset(a.3 + 0) = tmp.7 : set(), tmp.8 = a.3 != 100: set(), JumpIfZero(tmp.8, tmp.10): set()} ReachingCopies: set()
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: set()} ReachingCopies: set()
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): set(), tmp.11 = b != 10: set(), JumpIfZero(tmp.11, tmp.13): set()} ReachingCopies: set()
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: set()} ReachingCopies: set()
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {1, 3, 4}
--------------ADDING ALL STATIC VARIABLES.------------------
b b int InitialVal: InitialList: [c_int(0)] Global: True
callee callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True
ptr.0 ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>
target target FunType: ParamTypes: [] Return Type: int Defined: True Global: True
x.1 x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>
y.2 y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
a.3 a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>
tmp.5 tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>
tmp.6 tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>
tmp.7 tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>
tmp.8 tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>
tmp.9 tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>
tmp.11 tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>
tmp.12 tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>
--------------LIVE for block 4-------------------
Return 0 {b}
Label(tmp.13) {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 3-------------------
Return 2 {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 2-------------------
JumpIfZero(tmp.11, tmp.13) {b}
tmp.11 = b != 10 {tmp.11, b}
Label(tmp.10) {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 1-------------------
Return 1 {b}
OLD ANNOT: set()
NEW ANNOT: {b}
--------------LIVE for block 0-------------------
JumpIfZero(tmp.8, tmp.10) {b}
tmp.8 = a.3 != 100 {b, tmp.8}
CopyToOffset(a.3 + 0) = tmp.7  {a.3, b}
tmp.7 = target([]) {a.3, b, tmp.7}
OLD ANNOT: set()
NEW ANNOT: {a.3, b}
------------REMOVE DEAD STORE INSTRUCTIONS.-------------
------------AFTER DEAD STORE REMOVAL.-------------
ENTRY Entry: ENTRY {0}
0 0: [tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10)] Pred: {ENTRY} Suc: {1, 2} iMap: {tmp.7 = target([]): {a.3, b, tmp.7}, CopyToOffset(a.3 + 0) = tmp.7 : {a.3, b}, tmp.8 = a.3 != 100: {b, tmp.8}, JumpIfZero(tmp.8, tmp.10): {b}} ReachingCopies: {a.3, b}
1 1: [Return 1] Pred: {0} Suc: {EXIT} iMap: {Return 1: {b}} ReachingCopies: {b}
2 2: [Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13)] Pred: {0} Suc: {3, 4} iMap: {Label(tmp.10): {b}, tmp.11 = b != 10: {tmp.11, b}, JumpIfZero(tmp.11, tmp.13): {b}} ReachingCopies: {b}
3 3: [Return 2] Pred: {2} Suc: {EXIT} iMap: {Return 2: {b}} ReachingCopies: {b}
4 4: [Label(tmp.13), Return 0] Pred: {2} Suc: {EXIT} iMap: {Label(tmp.13): {b}, Return 0: {b}} ReachingCopies: {b}
EXIT Exit: EXIT {1, 3, 4}
TAC Program:[Function: callee (['ptr.0']) instructions:[tmp.4 = Load ptr.0 , Copy b = tmp.4, ptr.0 = Store 100 , Return 0], Function: target ([]) instructions:[CopyToOffset(x.1 + 0) = 10 , tmp.5 = Get Address x.1 , None = callee([tmp.5]), CopyToOffset(y.2 + 0) = x.1 , Return y.2], Function: main ([]) instructions:[tmp.7 = target([]), CopyToOffset(a.3 + 0) = tmp.7 , tmp.8 = a.3 != 100, JumpIfZero(tmp.8, tmp.10), Return 1, Label(tmp.10), tmp.11 = b != 10, JumpIfZero(tmp.11, tmp.13), Return 2, Label(tmp.13), Return 0], Global: True b = [c_int(0)]]
Type Table:
 {}
Symbol Table:
 {'b': b int InitialVal: InitialList: [c_int(0)] Global: True, 'callee': callee FunType: ParamTypes: [Pint] Return Type: void Defined: True Global: True, 'ptr.0': ptr.0 Pint <typeChecker.LocalAttributes object at 0x7ff4f6461e50>, 'target': target FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'x.1': x.1 int <typeChecker.LocalAttributes object at 0x7ff4f64621e0>, 'y.2': y.2 int <typeChecker.LocalAttributes object at 0x7ff4f64624e0>, 'main': main FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'a.3': a.3 int <typeChecker.LocalAttributes object at 0x7ff4f6462930>, 'tmp.4': tmp.4 int <typeChecker.LocalAttributes object at 0x7ff4f6463ce0>, 'tmp.5': tmp.5 Pint <typeChecker.LocalAttributes object at 0x7ff4f647c260>, 'tmp.6': tmp.6 Pint <typeChecker.LocalAttributes object at 0x7ff4f6463f20>, 'tmp.7': tmp.7 int <typeChecker.LocalAttributes object at 0x7ff4f647c380>, 'tmp.8': tmp.8 int <typeChecker.LocalAttributes object at 0x7ff4f647c560>, 'tmp.9': tmp.9 int <typeChecker.LocalAttributes object at 0x7ff4f647c2f0>, 'tmp.11': tmp.11 int <typeChecker.LocalAttributes object at 0x7ff4f647c890>, 'tmp.12': tmp.12 int <typeChecker.LocalAttributes object at 0x7ff4f647c650>}
Operand: Pseudo(ptr.0)
IntParams: [(<assemblyGenerator.Quadword object at 0x7ff4f647ea20>, Pseudo(ptr.0))]
IntParams: []
Operand: Pseudo(tmp.5)
IntArgs: [(<assemblyGenerator.Quadword object at 0x7ff4f648fb90>, Pseudo(tmp.5))]
DoubleArgs: []
StackArgs: []
IntParams: []
IntDests: [(<assemblyGenerator.Longword object at 0x7ff4f647d850>, Pseudo(tmp.7))]
DoubleDests: []
ReturnInMemory: False
IntArgs: []
DoubleArgs: []
StackArgs: []
<class 'parser.IntType'>
<class 'parser.IntType'>
ASM Program: [Function callee stackOffset: None global: True instructions:[AssType: <assemblyGenerator.Quadword object at 0x7ff4f647ea20> Mov(Reg(DI), Pseudo(ptr.0)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f6486cf0> Mov(Pseudo(ptr.0), Reg(AX)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6485130> Mov(Memory(AX, 0), Pseudo(tmp.4)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648caa0> Mov(Pseudo(tmp.4), Pseudo(b)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f647ddc0> Mov(Pseudo(ptr.0), Reg(AX)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6487cb0> Mov(Imm(100), Memory(AX, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648e150> Mov(Imm(0), Reg(AX)), ret], Function target stackOffset: None global: True instructions:[AssType: <assemblyGenerator.Longword object at 0x7ff4f648ca40> Mov(Imm(10), PseudoMem(x.1, 0)), Lea(Pseudo(x.1), Pseudo(tmp.5)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f648fb90> Mov(Pseudo(tmp.5), Reg(DI)), Call(callee), AssType: <assemblyGenerator.Longword object at 0x7ff4f6486ae0> Mov(Pseudo(x.1), PseudoMem(y.2, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648fb60> Mov(Pseudo(y.2), Reg(AX)), ret], Function main stackOffset: None global: True instructions:[Call(target), AssType: <assemblyGenerator.Longword object at 0x7ff4f647d850> Mov(Reg(AX), Pseudo(tmp.7)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495fa0> Mov(Pseudo(tmp.7), PseudoMem(a.3, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f647f080> Cmp(Imm(100), Pseudo(a.3)), AssType: <assemblyGenerator.Longword object at 0x7ff4f64967e0> Mov(Imm(0), Pseudo(tmp.8)), SetCC(ConcCodeType.NE, Pseudo(tmp.8)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6484080> Cmp(Imm(0), Pseudo(tmp.8)), JmpCC(ConcCodeType.E, tmp.10), AssType: <assemblyGenerator.Longword object at 0x7ff4f6494890> Mov(Imm(1), Reg(AX)), ret, Label(tmp.10), AssType: <assemblyGenerator.Longword object at 0x7ff4f64958e0> Cmp(Imm(10), Pseudo(b)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648f260> Mov(Imm(0), Pseudo(tmp.11)), SetCC(ConcCodeType.NE, Pseudo(tmp.11)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495580> Cmp(Imm(0), Pseudo(tmp.11)), JmpCC(ConcCodeType.E, tmp.13), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495940> Mov(Imm(2), Reg(AX)), ret, Label(tmp.13), AssType: <assemblyGenerator.Longword object at 0x7ff4f64956a0> Mov(Imm(0), Reg(AX)), ret], Static Variable: Global = True Alignment = 4 : b = [c_int(0)]]
Type Table:
 {}
Backend Symbol Table:
 {'b': AssType: <assemblyGenerator.Longword object at 0x7ff4f63bdac0> IsStatic: True IsConstant: False, 'callee': Defined: True ReturnOnStack: False, 'ptr.0': AssType: <assemblyGenerator.Quadword object at 0x7ff4f648ccb0> IsStatic: False IsConstant: False, 'target': Defined: True ReturnOnStack: False, 'x.1': AssType: <assemblyGenerator.Longword object at 0x7ff4f648f3e0> IsStatic: False IsConstant: False, 'y.2': AssType: <assemblyGenerator.Longword object at 0x7ff4f647f020> IsStatic: False IsConstant: False, 'main': Defined: True ReturnOnStack: False, 'a.3': AssType: <assemblyGenerator.Longword object at 0x7ff4f647d280> IsStatic: False IsConstant: False, 'tmp.4': AssType: <assemblyGenerator.Longword object at 0x7ff4f647e960> IsStatic: False IsConstant: False, 'tmp.5': AssType: <assemblyGenerator.Quadword object at 0x7ff4f6495ee0> IsStatic: False IsConstant: False, 'tmp.6': AssType: <assemblyGenerator.Quadword object at 0x7ff4f6496540> IsStatic: False IsConstant: False, 'tmp.7': AssType: <assemblyGenerator.Longword object at 0x7ff4f64959d0> IsStatic: False IsConstant: False, 'tmp.8': AssType: <assemblyGenerator.Longword object at 0x7ff4f6495a60> IsStatic: False IsConstant: False, 'tmp.9': AssType: <assemblyGenerator.Longword object at 0x7ff4f6496b40> IsStatic: False IsConstant: False, 'tmp.11': AssType: <assemblyGenerator.Longword object at 0x7ff4f6496180> IsStatic: False IsConstant: False, 'tmp.12': AssType: <assemblyGenerator.Longword object at 0x7ff4f6496d80> IsStatic: False IsConstant: False}
ASM Program: [Function callee stackOffset: -12 global: True instructions:[AssType: <assemblyGenerator.Quadword object at 0x7ff4f647ea20> Mov(Reg(DI), Memory(BP, -8)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f6486cf0> Mov(Memory(BP, -8), Reg(AX)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6485130> Mov(Memory(AX, 0), Memory(BP, -12)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648caa0> Mov(Memory(BP, -12), Data(b, 0)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f647ddc0> Mov(Memory(BP, -8), Reg(AX)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6487cb0> Mov(Imm(100), Memory(AX, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648e150> Mov(Imm(0), Reg(AX)), ret], Function target stackOffset: -20 global: True instructions:[AssType: <assemblyGenerator.Longword object at 0x7ff4f648ca40> Mov(Imm(10), Memory(BP, -4)), Lea(Memory(BP, -4), Memory(BP, -16)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f648fb90> Mov(Memory(BP, -16), Reg(DI)), Call(callee), AssType: <assemblyGenerator.Longword object at 0x7ff4f6486ae0> Mov(Memory(BP, -4), Memory(BP, -20)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648fb60> Mov(Memory(BP, -20), Reg(AX)), ret], Function main stackOffset: -16 global: True instructions:[Call(target), AssType: <assemblyGenerator.Longword object at 0x7ff4f647d850> Mov(Reg(AX), Memory(BP, -4)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495fa0> Mov(Memory(BP, -4), Memory(BP, -8)), AssType: <assemblyGenerator.Longword object at 0x7ff4f647f080> Cmp(Imm(100), Memory(BP, -8)), AssType: <assemblyGenerator.Longword object at 0x7ff4f64967e0> Mov(Imm(0), Memory(BP, -12)), SetCC(ConcCodeType.NE, Memory(BP, -12)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6484080> Cmp(Imm(0), Memory(BP, -12)), JmpCC(ConcCodeType.E, tmp.10), AssType: <assemblyGenerator.Longword object at 0x7ff4f6494890> Mov(Imm(1), Reg(AX)), ret, Label(tmp.10), AssType: <assemblyGenerator.Longword object at 0x7ff4f64958e0> Cmp(Imm(10), Data(b, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648f260> Mov(Imm(0), Memory(BP, -16)), SetCC(ConcCodeType.NE, Memory(BP, -16)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495580> Cmp(Imm(0), Memory(BP, -16)), JmpCC(ConcCodeType.E, tmp.13), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495940> Mov(Imm(2), Reg(AX)), ret, Label(tmp.13), AssType: <assemblyGenerator.Longword object at 0x7ff4f64956a0> Mov(Imm(0), Reg(AX)), ret], Static Variable: Global = True Alignment = 4 : b = [c_int(0)]]
-16
-32
-16
ASM Program: [Function callee stackOffset: -12 global: True instructions:[AssType: <assemblyGenerator.Quadword object at 0x7ff4f6487950> Binary(Sub, Imm(16), Reg(SP)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f647ea20> Mov(Reg(DI), Memory(BP, -8)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f6486cf0> Mov(Memory(BP, -8), Reg(AX)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6485130> Mov(Memory(AX, 0), Reg(R10d)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6485130> Mov(Reg(R10d), Memory(BP, -12)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648caa0> Mov(Memory(BP, -12), Reg(R10d)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648caa0> Mov(Reg(R10d), Data(b, 0)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f647ddc0> Mov(Memory(BP, -8), Reg(AX)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6487cb0> Mov(Imm(100), Memory(AX, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648e150> Mov(Imm(0), Reg(AX)), ret], Function target stackOffset: -20 global: True instructions:[AssType: <assemblyGenerator.Quadword object at 0x7ff4f6497440> Binary(Sub, Imm(32), Reg(SP)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648ca40> Mov(Imm(10), Memory(BP, -4)), Lea(Memory(BP, -4), Reg(R11d)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f64975c0> Mov(Reg(R11d), Memory(BP, -16)), AssType: <assemblyGenerator.Quadword object at 0x7ff4f648fb90> Mov(Memory(BP, -16), Reg(DI)), Call(callee), AssType: <assemblyGenerator.Longword object at 0x7ff4f6486ae0> Mov(Memory(BP, -4), Reg(R10d)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6486ae0> Mov(Reg(R10d), Memory(BP, -20)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648fb60> Mov(Memory(BP, -20), Reg(AX)), ret], Function main stackOffset: -16 global: True instructions:[AssType: <assemblyGenerator.Quadword object at 0x7ff4f64977a0> Binary(Sub, Imm(16), Reg(SP)), Call(target), AssType: <assemblyGenerator.Longword object at 0x7ff4f647d850> Mov(Reg(AX), Memory(BP, -4)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495fa0> Mov(Memory(BP, -4), Reg(R10d)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495fa0> Mov(Reg(R10d), Memory(BP, -8)), AssType: <assemblyGenerator.Longword object at 0x7ff4f647f080> Cmp(Imm(100), Memory(BP, -8)), AssType: <assemblyGenerator.Longword object at 0x7ff4f64967e0> Mov(Imm(0), Memory(BP, -12)), SetCC(ConcCodeType.NE, Memory(BP, -12)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6484080> Cmp(Imm(0), Memory(BP, -12)), JmpCC(ConcCodeType.E, tmp.10), AssType: <assemblyGenerator.Longword object at 0x7ff4f6494890> Mov(Imm(1), Reg(AX)), ret, Label(tmp.10), AssType: <assemblyGenerator.Longword object at 0x7ff4f64958e0> Cmp(Imm(10), Data(b, 0)), AssType: <assemblyGenerator.Longword object at 0x7ff4f648f260> Mov(Imm(0), Memory(BP, -16)), SetCC(ConcCodeType.NE, Memory(BP, -16)), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495580> Cmp(Imm(0), Memory(BP, -16)), JmpCC(ConcCodeType.E, tmp.13), AssType: <assemblyGenerator.Longword object at 0x7ff4f6495940> Mov(Imm(2), Reg(AX)), ret, Label(tmp.13), AssType: <assemblyGenerator.Longword object at 0x7ff4f64956a0> Mov(Imm(0), Reg(AX)), ret], Static Variable: Global = True Alignment = 4 : b = [c_int(0)]]
<class 'assemblyGenerator.Longword'>
0
	.globl callee
	.text
callee:
	pushq %rbp
	movq %rsp, %rbp
	subq $16, %rsp
	movq %rdi, -8(%rbp)
	movq -8(%rbp), %rax
	movl 0(%rax), %r10d
	movl %r10d, -12(%rbp)
	movl -12(%rbp), %r10d
	movl %r10d, b+0(%rip)
	movq -8(%rbp), %rax
	movl $100, 0(%rax)
	movl $0, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
	.globl target
	.text
target:
	pushq %rbp
	movq %rsp, %rbp
	subq $32, %rsp
	movl $10, -4(%rbp)
	leaq -4(%rbp), %r11
	movq %r11, -16(%rbp)
	movq -16(%rbp), %rdi
	call callee
	movl -4(%rbp), %r10d
	movl %r10d, -20(%rbp)
	movl -20(%rbp), %eax
	movq %rbp, %rsp
	popq %rbp
	ret
	.globl main
	.text
main:
	pushq %rbp
	movq %rsp, %rbp
	subq $16, %rsp
	call target
	movl %eax, -4(%rbp)
	movl -4(%rbp), %r10d
	movl %r10d, -8(%rbp)
	cmpl $100, -8(%rbp)
	movl $0, -12(%rbp)
	setNE -12(%rbp)
	cmpl $0, -12(%rbp)
	jE .Ltmp.10
	movl $1, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
.Ltmp.10:
	cmpl $10, b+0(%rip)
	movl $0, -16(%rbp)
	setNE -16(%rbp)
	cmpl $0, -16(%rbp)
	jE .Ltmp.13
	movl $2, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
.Ltmp.13:
	movl $0, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
	.globl b
	.bss
	.align 4
b:
	.zero 4
	.section	.note.GNU-stack,"",@progbits

gcc -ggdb /home/alejandro/CComp/test_/test.s -o /home/alejandro/CComp/test_/test -lm
