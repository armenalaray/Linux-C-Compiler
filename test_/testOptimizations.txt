sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)
9
['/home/alejandro/CComp/code/cd.py', '--tacky', '-lmath.h', '--fold-constants', '--propagate-copies', '--eliminate-unreachable-code', '--eliminate-dead-stores', '--optimize', '/home/alejandro/CComp/test_/test.c']
File: /home/alejandro/CComp/test_/test.c
Last Stage: tac
NoLink: False
NotAssembly: False
--fold-constants True
--propagate-copies True
--eliminate-unreachable-code True
--eliminate-dead-stores True
--optimize True
Libary: math.h
[('int', <TokenType.INT_KW: 4>, 1), ('i', <TokenType.IDENTIFIER: 2>, 1), ('=', <TokenType.EQUAL: 28>, 1), ('0', <TokenType.INT_CONSTANT: 3>, 1), (';', <TokenType.SEMICOLON: 11>, 1), ('int', <TokenType.INT_KW: 4>, 2), ('target', <TokenType.IDENTIFIER: 2>, 2), ('(', <TokenType.OPEN_PAREN: 7>, 2), ('int', <TokenType.INT_KW: 4>, 2), ('arg', <TokenType.IDENTIFIER: 2>, 2), (')', <TokenType.CLOSE_PAREN: 8>, 2), ('{', <TokenType.OPEN_BRACE: 9>, 2), ('i', <TokenType.IDENTIFIER: 2>, 3), ('=', <TokenType.EQUAL: 28>, 3), ('5', <TokenType.INT_CONSTANT: 3>, 3), (';', <TokenType.SEMICOLON: 11>, 3), ('i', <TokenType.IDENTIFIER: 2>, 4), ('=', <TokenType.EQUAL: 28>, 4), ('arg', <TokenType.IDENTIFIER: 2>, 4), (';', <TokenType.SEMICOLON: 11>, 4), ('return', <TokenType.RETURN_KW: 6>, 5), ('i', <TokenType.IDENTIFIER: 2>, 5), ('+', <TokenType.PLUS: 18>, 5), ('1', <TokenType.INT_CONSTANT: 3>, 5), (';', <TokenType.SEMICOLON: 11>, 5), ('}', <TokenType.CLOSE_BRACE: 10>, 6), ('int', <TokenType.INT_KW: 4>, 7), ('main', <TokenType.IDENTIFIER: 2>, 7), ('(', <TokenType.OPEN_PAREN: 7>, 7), ('void', <TokenType.VOID_KW: 5>, 7), (')', <TokenType.CLOSE_PAREN: 8>, 7), ('{', <TokenType.OPEN_BRACE: 9>, 7), ('int', <TokenType.INT_KW: 4>, 8), ('result1', <TokenType.IDENTIFIER: 2>, 8), ('=', <TokenType.EQUAL: 28>, 8), ('target', <TokenType.IDENTIFIER: 2>, 8), ('(', <TokenType.OPEN_PAREN: 7>, 8), ('2', <TokenType.INT_CONSTANT: 3>, 8), (')', <TokenType.CLOSE_PAREN: 8>, 8), (';', <TokenType.SEMICOLON: 11>, 8), ('}', <TokenType.CLOSE_BRACE: 10>, 9)]
<parser.Int object at 0x7f95cc1f3470>
[<parser.TypeS object at 0x7f95cc1f3260>]
[<class 'parser.Int'>]
int
int (IdenDeclarator: i)
int
<parser.Int object at 0x7f95cc1f31a0>
[<parser.TypeS object at 0x7f95cc1f3260>]
[<class 'parser.Int'>]
int
[<class 'parser.Int'>]
int (FunDeclarator: (IdenDeclarator: target) [int (IdenDeclarator: arg)])
FunType: ParamTypes: [int] Return Type: int
<parser.Int object at 0x7f95cc3db650>
[<parser.TypeS object at 0x7f95cc1f3230>]
[<class 'parser.Int'>]
int
int (FunDeclarator: (IdenDeclarator: main) [])
FunType: ParamTypes: [] Return Type: int
<parser.Int object at 0x7f95cc1f38f0>
[<parser.TypeS object at 0x7f95cc1f3920>]
[<class 'parser.Int'>]
int
int (IdenDeclarator: result1)
int
0
0
AST Program:
VarDecl: NULL int i = SI: (0)
FunDecl: NULL target (arg, ) ParamTypes: (int, ) ReturnType: int
Statement: Expression: ((i) = (5))
Statement: Expression: ((i) = (arg))
Statement: return ((i) ADD (1))
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int result1 = SI: (target((2), ))

OLD {}
NEW {}
OLD {}
NEW {}
0
0
AST Program:
VarDecl: NULL int i = SI: (0)
FunDecl: NULL target (arg.0, ) ParamTypes: (int, ) ReturnType: int
Statement: Expression: ((i) = (5))
Statement: Expression: ((i) = (arg.0))
Statement: return ((i) ADD (1))
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int result1.1 = SI: (target((2), ))

[(2 RetType: int)]
0
0
AST Program:
VarDecl: NULL int i = SI: (0 : int) : int
FunDecl: NULL target (arg.0, ) ParamTypes: (int, ) ReturnType: int
Statement: Expression: ((i : int) = (5 : int) : int)
Statement: Expression: ((i : int) = (arg.0 : int) : int)
Statement: return ((i : int) ADD (1 : int) : int)
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int result1.1 = SI: (target((2 : int), ) : int) : int

Type Table:
 {}
Symbol Table:
 {'i': i int InitialVal: InitialList: [c_int(0)] Global: True, 'target': target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True, 'arg.0': arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>, 'main': main FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'result1.1': result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>}
0
0
AST Program:
VarDecl: NULL int i = SI: (0 : int) : int
FunDecl: NULL target (arg.0, ) ParamTypes: (int, ) ReturnType: int
Statement: Expression: ((i : int) = (5 : int) : int)
Statement: Expression: ((i : int) = (arg.0 : int) : int)
Statement: return ((i : int) ADD (1 : int) : int)
FunDecl: NULL main () ParamTypes: () ReturnType: int
Declaration:
VarDecl: NULL int result1.1 = SI: (target((2 : int), ) : int) : int

i int InitialVal: InitialList: [c_int(0)] Global: True
target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True
arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>
main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>
tmp.2 int <typeChecker.LocalAttributes object at 0x7f95cc230ce0>
tmp.3 int <typeChecker.LocalAttributes object at 0x7f95cc231910>
tmp.4 int <typeChecker.LocalAttributes object at 0x7f95cc231850>
TAC Program:[Function: target (['arg.0']) instructions:[Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2, Return 0], Function: main ([]) instructions:[Copy tmp.3 = 2, tmp.4 = target([tmp.3]), CopyToOffset(result1.1 + 0) = tmp.4 , Return 0], Global: True i = [c_int(0)]]
Type Table:
 {}
Symbol Table:
 {'i': i int InitialVal: InitialList: [c_int(0)] Global: True, 'target': target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True, 'arg.0': arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>, 'main': main FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'result1.1': result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>, 'tmp.2': tmp.2 int <typeChecker.LocalAttributes object at 0x7f95cc230ce0>, 'tmp.3': tmp.3 int <typeChecker.LocalAttributes object at 0x7f95cc231910>, 'tmp.4': tmp.4 int <typeChecker.LocalAttributes object at 0x7f95cc231850>}
OPTIMIZING FUNCTION Function: target (['arg.0']) instructions:[Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2, Return 0]
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2, Return 0]
NEW LIST [Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2, Return 0]
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_BinaryInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
Copy i = 5
Return 0



ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = i + 1: set(), Return tmp.2: set()} ReachingCopies: set()
1 1: [Return 0] Pred: set() Suc: {EXIT} iMap: {Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0, 1}
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = i + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = i + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = i + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = i + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
Copy i = 5 set()
<class 'parser.ConstInt'>
Copy i = arg.0 {Copy i = 5}
tmp.2 = i + 1 {Copy i = arg.0}
Return tmp.2 {Copy i = arg.0}
OLD ANNOT: {Copy i = 5, Copy i = arg.0}
NEW ANNOT: {Copy i = arg.0}
ADD SUCCESSORS.
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: {Copy i = 5}, tmp.2 = i + 1: {Copy i = arg.0}, Return tmp.2: {Copy i = arg.0}} ReachingCopies: {Copy i = arg.0}
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
i i int InitialVal: InitialList: [c_int(0)] Global: True
target target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True
arg.0 arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
result1.1 result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>
tmp.2 tmp.2 int <typeChecker.LocalAttributes object at 0x7f95cc230ce0>
tmp.3 tmp.3 int <typeChecker.LocalAttributes object at 0x7f95cc231910>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7f95cc231850>
--------------LIVE for block 0-------------------
Return tmp.2 set()
tmp.2 = arg.0 + 1 {tmp.2}
Copy i = arg.0 {arg.0}
Copy i = 5 {arg.0}
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2]
NEW LIST [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2]
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_BinaryInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
Copy i = 5


ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = arg.0 + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = arg.0 + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = arg.0 + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: set(), tmp.2 = arg.0 + 1: set(), Return tmp.2: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
Copy i = 5 set()
<class 'parser.ConstInt'>
Copy i = arg.0 {Copy i = 5}
tmp.2 = arg.0 + 1 {Copy i = arg.0}
Return tmp.2 {Copy i = arg.0}
OLD ANNOT: {Copy i = 5, Copy i = arg.0}
NEW ANNOT: {Copy i = arg.0}
ADD SUCCESSORS.
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [Copy i = 5, Copy i = arg.0, tmp.2 = arg.0 + 1, Return tmp.2] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy i = 5: set(), Copy i = arg.0: {Copy i = 5}, tmp.2 = arg.0 + 1: {Copy i = arg.0}, Return tmp.2: {Copy i = arg.0}} ReachingCopies: {Copy i = arg.0}
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
i i int InitialVal: InitialList: [c_int(0)] Global: True
target target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True
arg.0 arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
result1.1 result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>
tmp.2 tmp.2 int <typeChecker.LocalAttributes object at 0x7f95cc230ce0>
tmp.3 tmp.3 int <typeChecker.LocalAttributes object at 0x7f95cc231910>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7f95cc231850>
--------------LIVE for block 0-------------------
Return tmp.2 set()
tmp.2 = arg.0 + 1 {tmp.2}
Copy i = arg.0 {arg.0}
Copy i = 5 {arg.0}
OPTIMIZING FUNCTION Function: main ([]) instructions:[Copy tmp.3 = 2, tmp.4 = target([tmp.3]), CopyToOffset(result1.1 + 0) = tmp.4 , Return 0]
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [Copy tmp.3 = 2, tmp.4 = target([tmp.3]), CopyToOffset(result1.1 + 0) = tmp.4 , Return 0]
NEW LIST [Copy tmp.3 = 2, tmp.4 = target([tmp.3]), Copy result1.1 = tmp.4, Return 0]
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_FunCallInstruction'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
Copy tmp.3 = 2


ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([tmp.3]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([tmp.3]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([tmp.3]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([tmp.3]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([tmp.3]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([tmp.3]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([tmp.3]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([tmp.3]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
Copy tmp.3 = 2 set()
<class 'parser.ConstInt'>
tmp.4 = target([tmp.3]) {Copy tmp.3 = 2}
Copy result1.1 = tmp.4 {Copy tmp.3 = 2}
Return 0 {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
OLD ANNOT: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
NEW ANNOT: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([tmp.3]): {Copy tmp.3 = 2}, Copy result1.1 = tmp.4: {Copy tmp.3 = 2}, Return 0: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}} ReachingCopies: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
i i int InitialVal: InitialList: [c_int(0)] Global: True
target target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True
arg.0 arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
result1.1 result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>
tmp.2 tmp.2 int <typeChecker.LocalAttributes object at 0x7f95cc230ce0>
tmp.3 tmp.3 int <typeChecker.LocalAttributes object at 0x7f95cc231910>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7f95cc231850>
--------------LIVE for block 0-------------------
Return 0 set()
Copy result1.1 = tmp.4 set()
tmp.4 = target([2]) {tmp.4}
<class 'tacGenerator.TAC_ConstantValue'>
Copy tmp.3 = 2 {i}
--------------ADDRESS TAKEN ANALYSIS.------------------
set()
-------------CONSTANT FOLDING PASS.--------------------
OLD LIST [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0]
NEW LIST [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0]
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_FunCallInstruction'>
<class 'tacGenerator.TAC_CopyInstruction'>
<class 'tacGenerator.TAC_returnInstruction'>
Copy tmp.3 = 2


ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([2]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([2]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([2]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([2]): set(), Copy result1.1 = tmp.4: set(), Return 0: set()} ReachingCopies: set()
EXIT Exit: EXIT {0}
--------------IMAP for block 0-------------------
Copy tmp.3 = 2 set()
<class 'parser.ConstInt'>
tmp.4 = target([2]) {Copy tmp.3 = 2}
Copy result1.1 = tmp.4 {Copy tmp.3 = 2}
Return 0 {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
OLD ANNOT: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
NEW ANNOT: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
------------REPLACE INSTRUCTIONS WITH REACHING COPIES.-------------
ENTRY Entry: ENTRY {0}
0 0: [Copy tmp.3 = 2, tmp.4 = target([2]), Copy result1.1 = tmp.4, Return 0] Pred: {ENTRY} Suc: {EXIT} iMap: {Copy tmp.3 = 2: set(), tmp.4 = target([2]): {Copy tmp.3 = 2}, Copy result1.1 = tmp.4: {Copy tmp.3 = 2}, Return 0: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}} ReachingCopies: {Copy tmp.3 = 2, Copy result1.1 = tmp.4}
EXIT Exit: EXIT {0}
--------------ADDING ALL STATIC VARIABLES.------------------
i i int InitialVal: InitialList: [c_int(0)] Global: True
target target FunType: ParamTypes: [int] Return Type: int Defined: True Global: True
arg.0 arg.0 int <typeChecker.LocalAttributes object at 0x7f95cc2304a0>
main main FunType: ParamTypes: [] Return Type: int Defined: True Global: True
result1.1 result1.1 int <typeChecker.LocalAttributes object at 0x7f95cc2308c0>
tmp.2 tmp.2 int <typeChecker.LocalAttributes object at 0x7f95cc230ce0>
tmp.3 tmp.3 int <typeChecker.LocalAttributes object at 0x7f95cc231910>
tmp.4 tmp.4 int <typeChecker.LocalAttributes object at 0x7f95cc231850>
--------------LIVE for block 0-------------------
Return 0 set()
Copy result1.1 = tmp.4 set()
tmp.4 = target([2]) {tmp.4}
<class 'tacGenerator.TAC_ConstantValue'>
Copy tmp.3 = 2 {i}
